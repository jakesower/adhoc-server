<html>
  <head>
    <title>Adhoc</title>
  </head>

  <body>
    <main>
      <!--
        Anything inside the <main> tag is fair game for use by widgets and
        should not be relied upon.

        The widgets catalog is itself something like a widgets. These templates
        and associated DOM parts should be removed once a proper widget has
        been initialized.
      -->
      <template id="catalog-item-template">
        <li>
          <span class="name"></span>
          <span class="description"></span>
        </li>
      </template>
    </main>

  <!-- Everything below here is JS and closing HTML tags -->
  <script type="text/javascript">
/**
  ADHOC BOOTSTRAPPER

  This page is the gateway to the Adhoc system. It performs the following vital
  functions:

  - Connects to rooms via multiple protocols
  - Reads widget catalogs, displays them, and allows their selection
  - Initializes widgets and passes control to them

  - Config object uses the following parameters:
  @param {string} widgetURI
*/

(function() {
  var config = {
    widgetCatalog: "http://localhost:3001/widgets.json",
    widgetPath: "http://localhost:3001",
    wsPath: "ws://localhost:8324"
  }

  window.adhoc = window.adhoc || {};


  function adhocInit() {
    var room = roomFromURI();

    room ?
      connectToRoom( room ) :
      presentWidgets();
  }


  function connectToRoom( room ) {
    var connection = createConnection( room );
    connection.send({ "type": "connect" });
  }


  function presentWidgets() {
    var template = document.getElementById( 'catalog-item-template' ).content;

    function populateTemplate( parts ) {
      var name = parts.name || "(no name)",
          description = parts.description || "(no description)";

      var newNode = document.importNode( template, true );

      Object.keys(parts).forEach( function( k ) {
        var n = newNode.querySelector( '.' + k );
        if( n ) { n.textContent = parts[ k ]; }
      });

      newNode.querySelector('li').dataset.location = parts.location;

      return newNode;
    }

    // may wish to refactor to use XHR rather than fetch for compatibility
    // also, may wish to use callbacks rather than promises
    fetch( config.widgetCatalog )
      .then( function( d ){ return d.json(); })
      .then( function( catalog ) {
        var widgetList = document.createElement('ul');
        catalog.widgets.forEach( function( widget ) {
          widgetList.appendChild( populateTemplate( widget ));
        });

        widgetList.addEventListener( 'click', function( event ) {
          var wPath = event.currentTarget.querySelector('li').dataset.location;
          // FIXME
          loadWidget(
            wPath,
            function() {
              var connection = createNewRoomConnection();
              connection.widgetPath = wPath;
              history.pushState({ room: connection.room }, "room", "?room=" + connection.room );
              window.adhoc.widget( connection );
            }
          );
        });

        document.querySelector( 'body > main' ).appendChild( widgetList );
      })
  }


  var systemHooks = {
    incoming: {
      connect: function( message, connection ) {
        connection.peersAwaitingConnection.push( message.peer );
        connection.onmessage({ type: 'getState' });
      },

      initialize: function( message, connection ) {
        loadWidget(
          message.widgetPath,
          function () {
            window.adhoc.widget( connection );
            connection.onmessage({ type: 'setState', state: message.state });
          }
        );
      }
    },

    outgoing: {
      state: function( message, connection ) {
        connection.peersAwaitingConnection.forEach( function( peer ) {
          connection.send({
            type: 'initialize',
            widgetPath: connection.widgetPath,
            state: message.state,
            to: peer
          });
        });
        connection.peersAwaitingConnection = [];
      }
    }
  }


  function loadWidget( path, callback ) {
    var uri = config.widgetPath + path;

    (function(d, script) {
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.async = true;
      script.onload = function() {
        script.onload = null;
        callback();
      };
      script.src = uri;
      document.getElementsByTagName('head')[0].appendChild(script);
    }(document));
  }


  function createConnection( room ) {
    var uri = room ? ( config.wsPath + '/' + room ) : config.wsPath,
        sock = new WebSocket( uri ),
        messageQueue = [];

    var connection = {
      send: function( msg ) {
        if( sock.readyState === 0 ) {
          messageQueue.push( msg );
        }
        else {
          console.log( 'sent:' );
          console.log( msg );
          var hook = systemHooks.outgoing[ msg.type ];
          hook ?
            hook( msg, connection ) :
            sock.send( JSON.stringify( msg ));
        }
      },
      onmessage: function() { },
      widgetPath: null,
      room: room,
      peersAwaitingConnection: []
    }

    sock.onopen = function () {
      messageQueue.forEach( function( msg ) { connection.send( msg )});
      messageQueue = [];
    }

    sock.onmessage = function( rawMsg ) {
      var msg = JSON.parse( rawMsg.data );
      var hook = systemHooks.incoming[ msg.type ];
      console.log( 'received:' );
      console.log( msg );

      hook ?
        hook( msg, connection ) :
        connection.onmessage( msg );
    }

    return connection;
  }


  function createNewRoomConnection() {
    // TODO: figure out how to deal with multiple people requesting the same
    //       room (this may be hard)
    return createConnection( randomSHA1() );
  }


  function randomSHA1() {
    var buf = new Uint8Array( 20 );
    window.crypto.getRandomValues( buf );
    out = '';
    for( var i=0; i < buf.length; i+=1 ) {
      var s = buf[i].toString( 16 );
      out = out + ( s.length === 1 ? '0' : '' ) + s;
    }
    return out;
  }


  function roomFromURI() {
    var isSHA1 = function( str ) { return /^[0-f]{40}$/.test( str ); }

    // first try the path
    var pathname = window.location.pathname.split("/"),
        roomURICand = config.room || pathname[ pathname.length - 1 ];

    if( isSHA1( roomURICand )) return roomURICand;

    // if that didn't work, try the query string
    var queryArgs = window.location.search.substring(1).split('&');
    var match = queryArgs.find( function( qa ) {
      return qa.split('=')[0] === 'room';
    });

    if( match ) {
      var cand = match.split('=')[1];
      if( isSHA1( cand )) return cand;
    }

    return null;
  }

  adhocInit();
}());


    </script>
  </body>
</html>
